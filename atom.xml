<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JudeJojoker ’s Blog</title>
  <icon>https://www.gravatar.com/avatar/3281e9b7282013796b1ee60a93993535</icon>
  <subtitle>光荣在于平淡，艰巨在于漫长</subtitle>
  <link href="http://sunrui.life/atom.xml" rel="self"/>
  
  <link href="http://sunrui.life/"/>
  <updated>2023-03-15T14:43:56.363Z</updated>
  <id>http://sunrui.life/</id>
  
  <author>
    <name>JudeJojoker</name>
    <email>cyalcz@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试算法笔记——详解桶排序以及排序总结</title>
    <link href="http://sunrui.life/posts/306cb7c5.html"/>
    <id>http://sunrui.life/posts/306cb7c5.html</id>
    <published>2023-03-09T06:59:36.000Z</published>
    <updated>2023-03-15T14:43:56.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解桶排序以及排序总结"><a href="#详解桶排序以及排序总结" class="headerlink" title="详解桶排序以及排序总结"></a>详解桶排序以及排序总结</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><ol><li>堆结构就是用数组实现的完全二叉树结构</li><li>完全二叉树中如果每棵子树的最大值都在顶端就是大根堆</li><li>完全二叉树中如果每棵子树的最小值都在顶端就是小根堆</li><li>堆结构的heapInsert与heapify操作</li><li>堆结构的增大和减少</li><li>优先级队列结构，就是堆结构</li></ol></blockquote><p>首先要了解什么是完全二叉树？</p><blockquote><p>完全二叉树是由满二叉树而引出来的，若设二叉树的<strong>深度为h</strong>，<strong>除第 h 层外</strong>，<strong>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</strong>，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p></blockquote><p>我们可以用数组来表示，从0开始的连续一段看作是完成全二叉树，用size来规定有几个数是这个树里。</p><p>他具有以下特性：</p><p>i位置的左孩子可以表示为：<script type="math/tex">2 \times i +1</script></p><p>右孩子：<script type="math/tex">2 \times i +2</script></p><p>父：<script type="math/tex">\frac{i-1}{2}</script></p><p>而堆是比较特殊的完全二叉树，所谓大根堆表示每一颗子树的最大值都是头节点的值，反之则是小根堆。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>在进行堆排序之前，让我们先引入heapInsert和heapify操作：</p><h4 id="heapInsert操作"><a href="#heapInsert操作" class="headerlink" title="heapInsert操作"></a>heapInsert操作</h4><p>以大根堆为例：</p><p>在算法中，我们可以先堆再比较，在插入一个数字时与他的父节点（<script type="math/tex">\frac{i-1}{2}</script>）比较，如果比他大的话就进行交换，如果交换后之后父节点还是小，那么再交换，也就是一直跟自己的父节点比较，什么时候来到头位置或者不再大，那么停止。这个插入的过程可以叫做heapinsert。同时还会有其他操作，比如告诉用户给的数字中最大的数字，同时拿掉这个数字，并且在这之后仍然成堆结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">        swap(arr , index , arr[(index - <span class="number">1</span>)/<span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="heapify操作"><a href="#heapify操作" class="headerlink" title="heapify操作"></a>heapify操作</h4><p><img src="http://cdn.sunrui.life/202303091422600.png" alt=""></p><p>以该图为例，heapSize=6，现在我们知道在第0个位置上就是当前最大的数字，我们先把这个数字用一个临时变量存储，记录下来，这时候把已经形成的堆结构的最后一个数字，也就是4，放在0位置上，同时heaoSize—，这时候arr[5]已经无效越界了，不再是堆的内容。但这时候整体可能就不再是堆。这时候我们从头节点开始，先在他的孩子中找一个最大值，并且进行比对，如果头节点比孩子小，那么交换，将这个“4”放下去。“5”放上去。停止的标志是不再有孩子或者不再小于孩子。这个过程叫heapify，堆化。</p><p><img src="http://cdn.sunrui.life/202303091426371.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt;heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr , index ,largest);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句判断什么时候右孩子可以放largest，首先右孩子要存在，并且比左孩子大，那么这个时候再将下标给largest。左孩子可以做最大值有两个可能，第一没有右孩子，第二右孩子比左孩子小，这一句包括了这两个判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt;heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br></pre></td></tr></table></figure><p>如果这之后largest的值就等于父节点的值，那就说明父节点就是最大值，不需要往下走，直接break，反之需要往下走。把largest和父做交换，index此时发生变化，并且有新的左孩子，继续走while判断，如果不再有孩子while停，有孩子但是孩子不比父亲大，break。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr , index ,largest);</span><br><span class="line">index = largest;</span><br><span class="line">left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>举个例子，此时已经排好了一个堆，但是用户想要将某个位置上的值换个数字，那么想要继续成堆，只需要判读这个数字和原数字谁大谁小。如果这个数字更大的话，那就执行heapInsert操作，将它往上放，反之，就执行heapify操作，将下面的部分调整成堆结构。</p><p><img src="http://cdn.sunrui.life/202303091446474.png" alt=""></p><p>在这张图中我们可以明显看到，完全二叉树的高度与有多少的节点的关系，所以是<script type="math/tex">O(logN)</script>级别。而heapInsert操作，只需要关注父这一条路径上去，只跟高度有关，所以是<script type="math/tex">logN</script>级别的。用户删掉最大值并且让之后继续成堆，还是往下走一条高度，所以也是<script type="math/tex">logN</script>级别的调整代价。</p><p>接下来我们正式进入堆排序的过程：</p><blockquote><ol><li>先让整个数组都变成大根堆结构，建立堆的过程：<br>(1). 从上到下的方法，时间复杂度为<script type="math/tex">O(N \times logN)</script><br>(2). <strong>从下到上的方法，时间复杂度为<script type="math/tex">O(N)</script></strong></li><li>把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为<script type="math/tex">O(N \times logN)</script></li><li>把堆的大小减少成0之后，排序完成</li></ol></blockquote><p><img src="http://cdn.sunrui.life/202303091504310.png" alt="image-20230309150405225"></p><ol><li>先让0～0范围上是堆，很显然已经是，接着是0～1，0～2，在这时，5和3需要交换，9要跟我交换，heapSize在变大。4进来需要跟3交换，6跟4交换，7跟5交换，0不用动。现在整个都是大根堆。（这是一个heapInsert过程。）</li></ol><p><img src="http://cdn.sunrui.life/202303091503216.png" alt="image-20230309150314125"></p><ol><li>接着把0位置上的9和6位置上的0做交换（最大值和堆上最后一个位置做交换），heapSize—变成6，即把最后的位置跟堆断开了。 9断开。</li></ol><p><img src="http://cdn.sunrui.life/202303091513885.png" alt="image-20230309151304820"></p><ol><li>然后从0位置上的0做heapify，让剩下的部分继续成堆结构。</li></ol><p><img src="http://cdn.sunrui.life/202303091509622.png" alt=""></p><ol><li><p>接着继续做交换，把最大与堆末尾交换，然后7断开。周而复始……</p><p><img src="http://cdn.sunrui.life/202303091514379.png" alt=""></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        heapInsert(arr , i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    swap(arr , <span class="number">0</span> , --heapSize);</span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr , <span class="number">0</span> ,heapSize);</span><br><span class="line">        swap(arr , <span class="number">0</span> , --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步将整体变成大根堆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; arr.length; i++)&#123;  <span class="comment">//O(n)</span></span><br><span class="line">    heapInsert(arr , i);  <span class="comment">//O(logN)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后和堆上最后一个位置的数做交换，堆大小减1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(arr , <span class="number">0</span> , --heapSize);</span><br></pre></td></tr></table></figure><p>只要heapSize大小没减成0就继续周而复始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>)&#123;  <span class="comment">//O(n)</span></span><br><span class="line">    heapify(arr , <span class="number">0</span> ,heapSize);  <span class="comment">//O(logN)</span></span><br><span class="line">    swap(arr , <span class="number">0</span> , --heapSize);  <span class="comment">//O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法整体复杂度为O(NlogN)，同时额外空间复杂度为O(1)。</strong></p><p>同时成大根堆的方法还可以从下往上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从下到上的成大根堆的方法，时间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length -<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">    heapify(arr , i , arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最底下一层有<script type="math/tex">\frac{N}{2}</script>个节点，倒数第二层<script type="math/tex">\frac{N}{4}</script>…这样一层一层的进行堆化操作，也可以成大根堆。时间复杂度为O(N)。</p><p>在最下面一层，几乎什么都不用干，所以时间复杂度为O(1)，往上一层的堆化则是需要1层的操作…</p><script type="math/tex; mode=display">T(N) = \frac{N}{2} \times 1 + \frac{N}{4} \times 2 + \frac{N}{8} \times 3 + \frac{N}{16} \times 4 + ...</script><script type="math/tex; mode=display">2T(N) = \frac{N}{2} \times 2 + \frac{N}{2} \times 2 + \frac{N}{4} \times 3 + \frac{N}{8} \times 4 + ...</script><p>得到：</p><script type="math/tex; mode=display">T(N) = N +\frac{N}{2} + \frac{N}{4} + \frac{N}{8} + ...$$  ，后面是个等比数列求和，最终结果就是O(N)。### 堆排序的拓展题目> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素的移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法对这个数据进行排序。意思就是说 数字所在的位置和他排完序应该在的位置不超过k。举例说明，假设k=6，准备一个小根堆（一个结构），然后遍历数组，先遍历前7个数，下标从0～6的七个数字扔到小根堆里，小根堆的最小值一定在0位置，将小根堆的最小值弹出，拿着这个数字放在0位置上，接着像滑动一样周而复始，最后数组临近结束时，只要依次将小根堆的最小数弹出，整个数组就几乎有序了。复杂度是$$O(NlogK)</script><p><strong>小根堆在Java中可以直接用优先级队列</strong>（堆结构，不加参数就是小根堆）表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>先把前k个数放到小根堆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//先把前k个数放到小根堆</span></span><br><span class="line"><span class="keyword">for</span>( ; index &lt;= Math.min(arr.length, k) ; index++)&#123;</span><br><span class="line">    heap.add(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加一个弹一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( ; index &lt; arr.length ; i++ , index++)&#123;</span><br><span class="line">    heap.add(arr[index]);</span><br><span class="line">    arr[i] = heap.poll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">    arr[i++] = heap.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><blockquote><ol><li>比较器的实质就是重载比较运算符</li><li>比较器可以很好的应用在特殊标准的排序上</li><li>比较器可以很好的应用在根据特殊标准排序的结构上</li></ol></blockquote><p>其实Java中的比较器就相当于C++中的重载比较运算符。</p><p>例如自己定义的一个Student，如果用系统自带的，只会比较无意义的内存地址。</p><p>通过控制返回值我们可以确定如何排序，所有的比较器的潜台词：返回负数的时候，第一个参数排在前面，返回正数的时候第二个参数排在前面，返回0谁在前面无所谓。那么对于堆结构，其实就相当于如果返回负数，第一个参数放在上面，返回正数则是第二个参数放在上面。</p><p>举个例子，在下面的代码中，如果o1的id小，返回的就是负数，o1就放前面，如果o2的id小，返回的就是负数，那么o2放前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IdAscendComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">        <span class="comment">//返回负数的时候，第一个参数排在前面</span></span><br><span class="line">        <span class="comment">//返回正数的时候，第二个参数排在前面</span></span><br><span class="line">        <span class="comment">//返回0的时候谁在前面无所谓</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1 , Student o2)</span>&#123;</span><br><span class="line"><span class="comment">//            return o1.id-o2.id;</span></span><br><span class="line">            <span class="keyword">if</span>(o1.id &lt; o2.id)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(o2.id &lt; o1.id)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该行代码表示的是，用你给的IdAscendingComparator方法去排序students：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students,<span class="keyword">new</span> <span class="title class_">IdAscendComparator</span>());</span><br></pre></td></tr></table></figure><h2 id="桶排序思想下的排序"><a href="#桶排序思想下的排序" class="headerlink" title="桶排序思想下的排序"></a>桶排序思想下的排序</h2><blockquote><ol><li>桶排序思想下的排序都是不基于比较大排序</li><li>时间复杂度为O(N)，额外空间复杂度O(M)</li><li>应用范围有限，需要样本的数据状况满足桶的划分</li></ol></blockquote><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>举个例子，现在需要对某公司的员工的年龄进行排序。在前面所有的排序都是基于比较得出的结论，而对于年龄来说，我们知道打工人的年龄在[16,200]之间，那么我们就可以定义一个数组，int age[]，数组的下标表示年龄，存放的数据表示遍历过整个公司的员工后等于下标年龄的员工的个数，这样一来就很容易再将其还原。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>以下图为例</p><p><img src="http://cdn.sunrui.life/202303151847978.jpeg" alt="IMG_C7023536AE94-1"></p><p>先根据个位数字排序，接着是十位，百位，百位是最后放桶里，所以优先级最高。而十进制是第二高优先级，个位也将优先级保留下来了。十进制数字使用十个桶，同理八进制就用八个桶。这也是根据数据状况产生的排序。</p><p>在数组[L~R]范围上要排序，digit代表这批数字中最大的值有几个十进制位。maxbits就是寻找最大值有多少位。getDigit是获取dight。</p><p><img src="http://cdn.sunrui.life/202303152149250.jpeg" alt=""></p><p><img src="http://cdn.sunrui.life/202303152233125.jpeg" alt="IMG_E9A019B4FE24-1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//only for no-negative value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radisSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        radixSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,maxbits(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxbits</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            max = Math.max(max,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[begin...end]排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> dight)</span>&#123;</span><br><span class="line">        <span class="comment">//以10为基底</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//有多少个数准备多少个辅助空间</span></span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        有多少位就进出几次：代表出桶入桶多少次，跟位数有关（最大的for循环的意思）</span></span><br><span class="line"><span class="comment">        十个空间</span></span><br><span class="line"><span class="comment">        count[0]  当前位(d位)是0的数字有多少个</span></span><br><span class="line"><span class="comment">        count[1]  当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line"><span class="comment">        count[2]  当前位(d位)是(0,1,3)的数字有多少个</span></span><br><span class="line"><span class="comment">        count[i]  当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= dight; d++)&#123;</span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[radix];</span><br><span class="line">            <span class="keyword">for</span>(i = L; i &lt;= R; i++)&#123;</span><br><span class="line">                j = getDight(arr[i],d);</span><br><span class="line">                count[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++)&#123;</span><br><span class="line">                count[i] = count[i] + count[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = R; i &gt;= L; i--)&#123;</span><br><span class="line">                j = getDight(arr[i],d);</span><br><span class="line">                bucket[count[j]-<span class="number">1</span>] = arr[i];</span><br><span class="line">                count[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++)&#123;</span><br><span class="line">                arr[i] = bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x / ((<span class="type">int</span>)Math.pow(<span class="number">10</span>,d-<span class="number">1</span>)))%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getDight"><a href="#getDight" class="headerlink" title="getDight"></a>getDight</h4><p><code>getDight(int x, int d)</code>中<code>x</code>代表传入的数字，<code>d</code>代表判断<code>x</code>的个位/十位/百位，返回值即为<code>x</code>的<code>d</code>位数。其中<code>Math.pow(x,y)</code>中x代表底数，y代表幂，整体代表<script type="math/tex">x^y</script>，我们知道求一个数字各个位数上的值可以用除法取模来计算。比如123想得到第十位上的值，首先就是将位数取成两位数，只需要除以一个十，即<script type="math/tex">123 \div 10 =12</script>（在计算机中整数除以整数会损失精度，得到的还是整数），再取模即可得到最后一位数的值。同理1234取百位是除以两个十…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="type">int</span>)Math.pow(<span class="number">10</span>,d-<span class="number">1</span>)))%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="maxbits"><a href="#maxbits" class="headerlink" title="maxbits"></a>maxbits</h4><p>maxbits求的是最大的数是几位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxbits</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        max = Math.max(max,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="radixSort"><a href="#radixSort" class="headerlink" title="radixSort"></a>radixSort</h4><p>这里的大循环是从个位开始，逐个放进桶里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= dight; d++)&#123;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[radix];</span><br><span class="line">    <span class="keyword">for</span>(i = L; i &lt;= R; i++)&#123;</span><br><span class="line">        j = getDight(arr[i],d);</span><br><span class="line">        count[j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++)&#123;</span><br><span class="line">        count[i] = count[i] + count[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = R; i &gt;= L; i--)&#123;</span><br><span class="line">        j = getDight(arr[i],d);</span><br><span class="line">        bucket[count[j]-<span class="number">1</span>] = arr[i];</span><br><span class="line">        count[j]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++)&#123;</span><br><span class="line">        arr[i] = bucket[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="count数组的形成"><a href="#count数组的形成" class="headerlink" title="count数组的形成"></a>count数组的形成</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = L; i &lt;= R; i++)&#123;</span><br><span class="line">    j = getDight(arr[i],d);</span><br><span class="line">    count[j]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化成前缀和形式</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++)&#123;</span><br><span class="line">    count[i] = count[i] + count[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入桶出桶"><a href="#入桶出桶" class="headerlink" title="入桶出桶"></a>入桶出桶</h5><p>从右往左遍历，<code>bucket</code>数组是辅助数组，在被赋值的同时<code>count[j]</code>递减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = R; i &gt;= L; i--)&#123;</span><br><span class="line">    j = getDight(arr[i],d);</span><br><span class="line">    bucket[count[j]-<span class="number">1</span>] = arr[i];</span><br><span class="line">    count[j]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后排序赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++)&#123;</span><br><span class="line">    arr[i] = bucket[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解桶排序以及排序总结&quot;&gt;&lt;a href=&quot;#详解桶排序以及排序总结&quot; class=&quot;headerlink&quot; title=&quot;详解桶排序以及排序总结&quot;&gt;&lt;/a&gt;详解桶排序以及排序总结&lt;/h1&gt;&lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="http://sunrui.life/tags/Java/"/>
    
    <category term="算法" scheme="http://sunrui.life/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="左程云" scheme="http://sunrui.life/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>面试算法笔记——认识O(NlogN)的排序</title>
    <link href="http://sunrui.life/posts/f6562d1e.html"/>
    <id>http://sunrui.life/posts/f6562d1e.html</id>
    <published>2023-03-06T11:40:42.000Z</published>
    <updated>2023-03-15T14:43:56.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识O（NlogN）的排序"><a href="#认识O（NlogN）的排序" class="headerlink" title="认识O（NlogN）的排序"></a>认识O（NlogN）的排序</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>首先有这样一个问题：我们在二分时喜欢用：</p><p>mid=（L+R）/2来表示，然而这么做却有一定的问题，L+R可能会溢出int的长度范围</p><p>所以可以写成：</p><p><strong>mid=L+(R-L)/2;</strong></p><p>再简化：mid = L + （（R- L））&gt;&gt; 1）； <strong>右移一位相当于除以二，左移相当于乘</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code08_GetMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr从L到R的范围求最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> L ,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == R)&#123; <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span> arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R-L) &gt;&gt; <span class="number">1</span>); <span class="comment">//中点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> process(arr, L ,mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> process(arr, mid+<span class="number">1</span> ,R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：比如有个数组[3,2,5,6,7,4]；</p><p><img src="http://cdn.sunrui.life/202303062006317.png" alt=""></p><p>递归的过程其实就是压栈 （先进后出），执行p（0，5）的时候我们知道要先调p（0，2），所以p（0，5）进栈。这是一个后序遍历。</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><script type="math/tex; mode=display">T(N) = a \times T(\frac{N}{b})+O(N^d)</script><p>T(N)指的是母问题的数据量是N，等号右边是函数里的细节。其中$T(\frac{N}{b})$代表每次的子过程的规模，a则代表子过程的调用次数，再后面是除了子过程之外剩下的过程的时间复杂度。</p><p>对于上面那行代码：<script type="math/tex">T(N)=2 \times T(\frac{N}{2})+O(1)</script></p><p><strong><script type="math/tex">T(N) = a \times T(\frac{N}{b})+O(N^d)</script></strong></p><p>同时,一旦参数确定，时间复杂度即可确定</p><p>如果<script type="math/tex">log_b{a} < d</script> 时间复杂度为<script type="math/tex">O(N^d)</script></p><p>如果<script type="math/tex">log_b{a} > d</script> 时间复杂度为<script type="math/tex">O(N^{log_b{a}})</script></p><p>如果<script type="math/tex">log_b{a} = d</script> 时间复杂度为<script type="math/tex">O(N^d \times logN)</script></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol><li>整体就是一个简单递归，左边排好序，右边排好序，让其整体有序</li><li>让其整体有序的过程里用了排外序方法</li><li>利用master公式求解时间复杂度i</li><li>归并排序的实质</li></ol><p>时间复杂度<script type="math/tex">O(N \times logN)</script>，额外空间复杂度O（N）</p><p>思路：想从L到R范围排好序，先把中点M分出左右，接着合并两个有序数组，使得合并的数组依然有序。</p><p>process是递归，先让左右都有序，再让整体有序。merge不是一个递归行为。</p><p>help是一个辅助空间，开辟的个数由L和R决定，跟原先数组等规模。</p><p>i是专门给help使用的一个变量。</p><p>p1是左侧部分的下标，p2是右侧部分下标。</p><p>首先判断是否越界，p1不超过M，p2不超过R，都不越界，谁小将谁拷贝到help里面，并且i也往下走。 </p><p>但是总会有一个时刻会有越界，如果p1没越界，就把剩下的拷贝进去，两个while只会走一个。</p><p>再把help里的东西拷贝回原数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> L ,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == R)&#123; <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R-L) &gt;&gt; <span class="number">1</span>); <span class="comment">//中点</span></span><br><span class="line">        process(arr, L ,mid);</span><br><span class="line">        process(arr, mid+<span class="number">1</span> ,R);</span><br><span class="line">        merge(arr,L,mid,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> M)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">            help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] :arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= M)&#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= R)&#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">            arr[L + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="http://cdn.sunrui.life/202303062134076.png" alt=""></p><h3 id="归并排序的拓展"><a href="#归并排序的拓展" class="headerlink" title="归并排序的拓展"></a>归并排序的拓展</h3><h4 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h4><blockquote><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p><p>例子：[1,3,4,2,5]，1左边比1小的数没有；3左边比3小的数字：1；4左边比4小的数：1，3；2左边比2小的数：1；5左边比5小的数：1，3，4，2；所以小和为1+1+3+1+1+3+4+2=16</p></blockquote><p>可以采用逆向思维的方法，对于1来说，右边比1大的有四个，就是说会有四个1，对于3来说，两个3，一个4，一个2。求一个数右边有多少个数比他大用归并排序很方便。</p><p>回想归并排序的过程，首先是分一半再分直到分到最后，那么这个过程中，在最底层逐渐弹栈时比较。</p><p>用以下图片举例：</p><p><img src="http://cdn.sunrui.life/202303062204329.png" alt=""></p><p>对于[1，3，4，2，5]这个数组，从最底下来看，一步一步merge：</p><p>首先是分成了[1,3]，在这里面3在1右边比1大，有一个1。接着抹去最底下一层（递归弹出）merge成[1,3]。</p><p>数组变成了[[1,3],4]，双指针，先从1看，左指针p1跟右指针p2=4比较，一个1；接着p1+1，3也比4小，一个3，然后左指针越界，将4拷贝下来merge成[1,3,4]。</p><p>然后问题来到整个数组的右侧，即[2,5]部分：左侧指向2，右侧指向5，拷贝的时候 左侧小产生一个2，然后左侧越界，右侧小的时候不产生小和，所以只产生了一个2.</p><p>然后[[1,3,4]，[2，5]]，左侧指针指向1，右侧指针指向2，可以看出左侧产生两个1， 然后左侧指向3，右侧有一个比3大，产生一个3，接下来是4，产生一个4，再越界，merge成[1.2.3.4.5]。</p><p><strong>但是要注意，与归并排序不同的地方在于，求小和的时候当遇到两个数相等的时候需要将右侧的先拷贝。</strong></p><p><img src="http://cdn.sunrui.life/202303082122760.png" alt=""></p><p>如上图所示：</p><p>第一个1和右侧指针指向的都是1，但是会先把右侧的拷贝下来，这样才能让指针继续向右走，才能继续看有多少个数比1大（注意，上图是已经走到最后一步的时候，两个数组已经排序好了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_SmallNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallSum</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[L..R]既要排好序也要求小和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> L ,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == R)&#123; <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R-L) &gt;&gt; <span class="number">1</span>); <span class="comment">//中点</span></span><br><span class="line">        <span class="keyword">return</span> process(arr, L ,mid) +process(arr, mid+<span class="number">1</span> ,R) +merge(arr,L,mid,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> M)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">            <span class="comment">/*都不越界的时候只有左边比右边小的时候，</span></span><br><span class="line"><span class="comment">             R-p2+1指的是当前有多少个比左边的大，然后乘上这个小数，</span></span><br><span class="line"><span class="comment">             如果不比右边的小，就是0。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            res += arr[p1] &lt; arr[p2] ? (R - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = arr[p1] &lt;=arr[p2] ? arr[p1++] :arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= M)&#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= R)&#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;help.length; i++)&#123;</span><br><span class="line">            arr[L + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么可以做到不重不漏呢？</p><p>以数组中c举例：</p><p><img src="http://cdn.sunrui.life/202303082310095.png" alt=""></p><p>在形成这样一个数组之前，ab有序之前，肯定经历过合并，比如从[a,b,c]合成[a,b,c,d,e]，在这样的过程中，不论c的位置，在跟[d,e]合的时候在向右扩大并且在排序，去寻找小和，往右是一个不断扩大的过程。而往左，已经排序好了，一个合并好的数组是不会产生小和的，c只是普通的一员。类比成抓牌其实很容易理解。</p><h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><blockquote><p>在一个数组中，左边的数如果比右边的数字大，则这两个数构成一个逆序对，请找到逆序对的数量。</p></blockquote><p>与求小和问题一样，只是方向相反。</p><h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>1.</p><blockquote><p>给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边，要求额外空间复杂度是O(1)，时间复杂度O(N)。</p></blockquote><p>没有要求左右两边有序。</p><p><img src="http://cdn.sunrui.life/202303082317410.png" alt=""></p><p>2.</p><blockquote><p>给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边，要求额外空间复杂度是O(1)，时间复杂度O(N)。</p></blockquote><p>第三个条件原地不动因为换过来了还没判断。</p><p><img src="http://cdn.sunrui.life/202303090845106.png" alt=""></p><p><img src="http://cdn.sunrui.life/202303090847521.png" alt=""></p><h3 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h3><p>以下是来自曹利荣博客的内容</p><p><a href="https://blog.csdn.net/pengzonglu7292/article/details/84938910">快速排序（过程图解）</a></p><p><img src="https://img-blog.csdnimg.cn/20181210145300437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6b25nbHU3Mjky,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="快排2-0"><a href="#快排2-0" class="headerlink" title="快排2.0"></a>快排2.0</h3><p>2.0版本把基准数都放在中间，并且解决了一批基准数，然后两边再继续递归，实际上比1.0稍快一些。</p><p><img src="http://cdn.sunrui.life/202303090900018.png" alt=""></p><p>两个快排的时间复杂度都是<script type="math/tex">O(N^2)</script>，好情况是基准值几乎就在中间，这时候<script type="math/tex">T(N)=2 \times T(\frac{N}{2})+O(N)</script>，即<script type="math/tex">O(N \times logN)</script>，差情况是基准值最左或最右。</p><h3 id="快排3-0"><a href="#快排3-0" class="headerlink" title="快排3.0"></a>快排3.0</h3><p>即人为随机选一个数放到基准数，这样的话划分出来的位置好情况和坏情况就成了概率事件。最后的时间复杂度是<script type="math/tex">O(N \times logN)</script></p><p><img src="http://cdn.sunrui.life/202303090937609.png" alt=""></p><p>partition的过程就是将基准值5放到了中间，并且只返回两个数，即基准值等于区的左和右边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code06_QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr , <span class="number">0</span> , arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**arr[L...R]排序好</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> L</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R</span></span><br><span class="line"><span class="comment">     * 第一步等概率随机算一个位置，把他跟基准数（最右侧的数）做交换</span></span><br><span class="line"><span class="comment">     * 然后在L，R范围上做partition</span></span><br><span class="line"><span class="comment">     * 返回的数组长度一定为2</span></span><br><span class="line"><span class="comment">     * p[0]是等于区域的左边界，-1即是小于区的右边界，然后递归</span></span><br><span class="line"><span class="comment">     * P[1]是等于区的右边界，+1即是大于区左边界，然后递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr , <span class="type">int</span> L , <span class="type">int</span> R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">            swap(arr , L + (<span class="type">int</span>)(Math.random()*(R-L+<span class="number">1</span>)),R);</span><br><span class="line">            <span class="type">int</span>[] p = partition(arr , L , R);</span><br><span class="line">            quickSort(arr , L , p[<span class="number">0</span>]-<span class="number">1</span>);  <span class="comment">//小于区</span></span><br><span class="line">            quickSort(arr , p[<span class="number">1</span>]+<span class="number">1</span> , R);  <span class="comment">//大于区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这是一个处理arr[L...R]的函数，</span></span><br><span class="line"><span class="comment">     * 默认以arr[R]做划分（基准数），arr[R] -&gt; p   &lt;p    ==p    &gt;p</span></span><br><span class="line"><span class="comment">     * 返回等于区域（左边界，右边界）所以返回一个长度为2的数组res，res[0]，res[1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr , <span class="type">int</span> L , <span class="type">int</span> R) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> L - <span class="number">1</span>;  <span class="comment">//小于区右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> R;  <span class="comment">//大于区左边界</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; more) &#123;  <span class="comment">//L表示当前数的位置 arr[R] -&gt; 基准数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[L] &lt; arr[R]) &#123; <span class="comment">//当前值小于基准数</span></span><br><span class="line">                swap(arr, ++less, L++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R]) &#123;  <span class="comment">//当前值大于基准数</span></span><br><span class="line">                swap(arr, --more, L);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr , more , R);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;less + <span class="number">1</span> , more &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr , <span class="type">int</span> i , <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>(int)(Math.random()*(R-L+1))</code></p><p>不要写成</p><p><code>(int)(Math.Random())*(R-L+1)</code>。这样的结果一直为0.</p><p>快速排序的额外空间复杂度是<script type="math/tex">O(logN)</script>，也是因为基准值的位置导致好情况和坏情况，与时间复杂度相似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识O（NlogN）的排序&quot;&gt;&lt;a href=&quot;#认识O（NlogN）的排序&quot; class=&quot;headerlink&quot; title=&quot;认识O（NlogN）的排序&quot;&gt;&lt;/a&gt;认识O（NlogN）的排序&lt;/h1&gt;&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://sunrui.life/tags/Java/"/>
    
    <category term="算法" scheme="http://sunrui.life/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="左程云" scheme="http://sunrui.life/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>面试算法笔记(1)</title>
    <link href="http://sunrui.life/posts/8cb6891e.html"/>
    <id>http://sunrui.life/posts/8cb6891e.html</id>
    <published>2023-03-06T07:14:13.000Z</published>
    <updated>2023-03-15T14:43:56.362Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记内容均来源于左程云老师课程</p><p><a href="https://www.bilibili.com/video/BV13g41157hK/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=ddd622c5127a32124555e8ca591e5403">一周刷爆Leetcode</a></p><h1 id="认识复杂度和简单排序算法"><a href="#认识复杂度和简单排序算法" class="headerlink" title="认识复杂度和简单排序算法"></a>认识复杂度和简单排序算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一般采用大O表示法，同时省去常数项</p><blockquote><p>时间复杂度是一个算法流程中，常熟操作数量的一个指标，常用O表示。在表达式中过，只需要高阶项，不需要低阶项，也不需要高阶项大系数，剩下的部分如果为f(n)，那么时间复杂度即为O(f(n))。</p></blockquote><p>评价一个算法流程的好坏，先看时间复杂度的指标，再分析不同数据样本在的实际运行时间，也就是“常数项时间”</p><h3 id="常数操作"><a href="#常数操作" class="headerlink" title="常数操作"></a>常数操作</h3><blockquote><p>一个操作如果与样本的数据量没有关系，每次都是固定时间内完成的操作叫做常数操作。</p></blockquote><h2 id="简单排序算法"><a href="#简单排序算法" class="headerlink" title="简单排序算法"></a>简单排序算法</h2><h3 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelcetionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="literal">null</span> || array.length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="comment">/*选择排序的思想就是：</span></span><br><span class="line"><span class="comment">            首先从0到n-1之间选出最小的数字，并将其放在首位</span></span><br><span class="line"><span class="comment">            接着继续从1到n-1之间继续选择，直到选到最后</span></span><br><span class="line"><span class="comment">            minIndex代表选出的下标</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="comment">//这一步其实就是双重循环进行选择</span></span><br><span class="line">                minIndex = array[minIndex] &gt; array[j] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i,minIndex,array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j , <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此过程中，开辟了变量i，变量j，且minIndex还会释放，那么空间复杂度为O(1)。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这里用<strong>谁大谁往右移动</strong>的思想，首先是从第0个位置到第n-1个位置（搞定了最后一个位置，把最大的数字放到了最右边），接着循环往次，从第0个位置到第n-2个位置。那么相对应的，也可以是比较出最小的往左边移动，只不过循环的方式需要改变，就是从第0到n-1变为第1到n-1往次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span> ||arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length-<span class="number">1</span> ; i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                从第0号下标开始，向最后一个来寻找最大第值放到最右边，</span></span><br><span class="line"><span class="comment">                多重循环先从最里面开始看，那么这里代表的就是从0到n-1再从0到n-2</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换arr的i和j位置上的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：异或操作"><a href="#补充：异或操作" class="headerlink" title="补充：异或操作"></a>补充：异或操作</h3><blockquote><p>相同为0，不同为1。举例：a:10110;b:00111 ，那么a^b的结果就是10001 。同时异或操作还可以理解为无进位相加</p></blockquote><p>性质：</p><ul><li>0^n=n</li><li>n^n=0</li><li>异或运算满足交换律和结合律</li><li>同一批数字异或的结果相同（例如二进制数字无进位相加，其结果其实只跟1出现的次数有关，这样可以解释为什么满足）</li></ul><p>那么：假设int a =甲,int b = 乙</p><p>a=a^b;    =&gt; a = 甲 ^ 乙 ，b = 乙</p><p>b=a^b;    =&gt; a = 甲 ^ 乙 ，b= 甲 ^ 乙 ^乙，再根据交换律，乙 ^乙= 0 ，而甲 ^ 0 = 甲     =&gt;b = 甲</p><p>a=a^b;    =&gt; a = 甲 ^ 乙 ^ 甲 =乙， b = 甲</p><p>这三行代码的作用其实就是交换，但是<strong>能这么做的前提是a和b在内存里是两块独立的区域</strong> ，即a可以等于b，值可以一样，但是必须保证a所指向的内存和b指向的内存不一样。如果相同内存地址，那么会被抹成0。</p><h4 id="题目举例"><a href="#题目举例" class="headerlink" title="题目举例"></a>题目举例</h4><p>（1）已知在一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这个数字</p><p>（2）..两种数字，找到这两个数字</p><p>要求时间复杂度为O(n)，空间复杂度为O(1)。</p><p>思路：</p><p>（1）偶数次的数字异或之后都会变成0，那么再结合异或操作的结合律和交换律，将整个数组与0异或就可以得到剩下的那个数字。</p><p>（2）不妨假设这两个数字是a和b，剩下其他的都是出现偶数次的，那么最后的结果一定是eor=a^b，且a不等于b，且eor不等于0。那么可以推断出eor一定至少有一位不为0，假设就在第八个位置上（整数一共32位），那么就说明a与b在第8个位置上不一样。那么再准备一个变量eor1，让整个数组的第八位上只为1的数再与eor1异或，a和b一定会分出来在两个集合中，一个是第八位为0的一个是第八位为1的。eor1=a or b。eor再与eor1异或就可以得到另一个。</p><p><img src="http://cdn.sunrui.life/image-20230306141859684.png" alt="image-20230306141859684"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_EvenTimesOddTimes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//已知在一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur : arr)&#123;</span><br><span class="line">            eor ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(eor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//已知在一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span> , eor1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curNum : arr)&#123;</span><br><span class="line">            eor ^= curNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        eor = a ^ b;</span></span><br><span class="line"><span class="comment">        eor != 0</span></span><br><span class="line"><span class="comment">        eor必然至少有一个位置上是1</span></span><br><span class="line"><span class="comment">        RightOne是最右边为1 的</span></span><br><span class="line"><span class="comment">        在if判断的时候不管是1还是0都可以，只做分类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">RightOne</span> <span class="operator">=</span> eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>((cur &amp; RightOne) == <span class="number">0</span>)&#123;</span><br><span class="line">                eor1 ^= cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(eor1 + <span class="string">&quot; &quot;</span> + (eor ^ ero1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~eor是eor取反</p><p><img src="http://cdn.sunrui.life/20230306143743.png" alt="示例图"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>其时间复杂度是O(n^2)，空间复杂度O(1)。</p><p>先做到0-0范围上有序，然后是0-1，如果1位置上的数字比0位置小，那么换位置，从1往前看。同理在0-n上，从n往前看。类比于斗地主抓牌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span> ||arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0-1是有序的，0-i想有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp;arr[j]&gt;arr[j+<span class="number">1</span>]; j--)&#123;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于时间复杂度：数据状况不同时间复杂度按最差来看</p><h3 id="二分法的详解与拓展"><a href="#二分法的详解与拓展" class="headerlink" title="二分法的详解与拓展"></a>二分法的详解与拓展</h3><ol><li><p>在一个有序数组中，找某个数是否存在:一半一半的范围找，一次砍一半的范围。时间复杂度是O(logn)</p></li><li><p>在一个有序数组中，找&gt;=某个数最左侧的位置</p><p><img src="http://cdn.sunrui.life/202303061510523.png" alt=""></p></li><li><p>局部最小值的问题，arr<strong>无序</strong>，但是任何两个相邻的数字不相等</p></li></ol><p>可以用二分的思维（类似于连续函数介值定理）</p><p><img src="http://cdn.sunrui.life/202303061521124.png" alt=""></p><h3 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h3><ol><li>有一个你想要测的方法a</li><li>时间复杂度不好但是容易实现的方法b</li><li>实现一个随机样本产生器</li><li>把方法a和方法b爬相同的随机样本，看看得到结果是否一样</li><li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者b</li><li>当样本数量很多时对比测试依然正确，可以确定方法a以及正确</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span> ||arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0-1是有序的，0-i想有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp;arr[j]&gt;arr[j+<span class="number">1</span>]; j--)&#123;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compataror</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        Arrays.sort(arr);  <span class="comment">//系统提供的排序，当作对数器的方法B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> maxSize,<span class="type">int</span> maxValue)&#123;</span><br><span class="line">        <span class="comment">//Math.random(): [0,1）之间的所有小数，等概率随机返回一个</span></span><br><span class="line">        <span class="comment">//Math.random*N: [0,N)之间的所有小数，等概率随机返回一个</span></span><br><span class="line">        <span class="comment">//int(Math.random*N):[0,N-1)之间的所有整数，等概率随机返回一个</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[((<span class="type">int</span>)((maxSize+<span class="number">1</span>)*Math.random()))];  <span class="comment">//长度随机</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)((maxValue+<span class="number">1</span>)*Math.random())-(<span class="type">int</span>)((maxValue)*Math.random());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyArray(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEuqul</span><span class="params">(<span class="type">int</span>[] arr1,<span class="type">int</span>[] arr2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((arr1 == <span class="literal">null</span> &amp;&amp; arr2 != <span class="literal">null</span>) || (arr1 != <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr1 == <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] != arr2[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:arr</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] arr1 = generateRandomArray(maxSize,maxValue);</span><br><span class="line">            <span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">            insertionSort(arr1);</span><br><span class="line">            compataror(arr2);</span><br><span class="line">            <span class="keyword">if</span>(!isEuqul(arr1,arr2))&#123;</span><br><span class="line">                succeed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(succeed ? <span class="string">&quot;Nice&quot;</span> : <span class="string">&quot;Fucking fucked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本笔记内容均来源于左程云老师课程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV13g41157hK/?p=3&amp;amp;spm_id_from=pageDriver&amp;amp;vd_source=ddd622c5127a32</summary>
      
    
    
    
    
    <category term="算法" scheme="http://sunrui.life/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="左程云" scheme="http://sunrui.life/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记（2）</title>
    <link href="http://sunrui.life/posts/205bf421.html"/>
    <id>http://sunrui.life/posts/205bf421.html</id>
    <published>2023-03-02T07:34:42.000Z</published>
    <updated>2023-03-15T14:43:56.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><h2 id="注释、标识符、关键字"><a href="#注释、标识符、关键字" class="headerlink" title="注释、标识符、关键字"></a>注释、标识符、关键字</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>在我们写代码时，如果代码量比较小，我们还可以自己看懂，但是当项目结构复杂起来，我们需要用到注释来让自己和别人理解。</p></blockquote><p>注释并不会被执行，<strong>书写注释是一个很好的习惯</strong>。写代码时一定要注意规范。</p><p>Java的注释有三种，分别是</p><ul><li>单行注释：用“//”表示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这是单行注释，输出一个HelloWorld</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多行注释：以“/<em> 注释 </em>/”，可以注释一段文字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这是多行注释</span></span><br><span class="line"><span class="comment">        可以写很多行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文档注释：以“/<em>* 注释 </em>/”，有功能可以被识别到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Description</span> HelloWorld</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Author</span> JudeJojoker</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><blockquote><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p></blockquote><p>标识符规范：</p><ol><li>所有的标识符都应该以字母（A- Z或者a-z），美元符号（$），或者下划线（_）开始。</li><li>首字母之后可以是字母，美元符号，下划线或者数字的任何字符组合。</li><li><strong>不能使用关键字作为变量名或者方法名</strong>，</li><li>标识符也是<strong>大小写敏感</strong>的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识符大小写敏感</span></span><br><span class="line"><span class="type">String</span> <span class="variable">Man</span> <span class="operator">=</span> <span class="string">&quot;JudeJojoker&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">man</span> <span class="operator">=</span> <span class="string">&quot;JudeJojoker&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li><p>合法标识符举例：age，$salary，<em>value</em>，_1_value</p></li><li><p>非法标识符举例：123abc，-salary，#abc</p></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://img1.sycdn.imooc.com/5ea9345000019d8d04980337.png" alt="Java 关键字大全"></p><h2 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h2><blockquote><p>位（bit）：是计算机内部数据储存的最小单位，11001100是一个八位二进制数。</p><p>字节（byte）：是计算机中数据处理的基本单位，习惯上用大写的B表示。</p><p>1B（byte，字节）=8bit（位）</p><p>字符：是指计算机中使用的字母、数字、字和符号</p></blockquote><p>1bit表示1位，1Byte表示一个字节，1B=8b，1024B=1K B，1024KB=1M，1024M=1G。</p><p>那么电脑的32位和64位的区别就显而易见了，32位的操作系统只可以用32位的CPU，64位的都可以装，64位最多可以支持128G内存，32位则为4GB。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="强类型语言"><a href="#强类型语言" class="headerlink" title="强类型语言"></a>强类型语言</h3><p>Java，C++都是一种强类型语言</p><blockquote><p>要求变量的使用要严格符合规定，所有的变量都必须<strong>先定义以后才可以使用</strong>。弊端是速度比较慢，但是更安全。</p></blockquote><h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><p>VB，JS都是弱类型语言</p><blockquote><p>不需要严格符合规定</p></blockquote><h3 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h3><h4 id="基本类型（primitive-type）"><a href="#基本类型（primitive-type）" class="headerlink" title="基本类型（primitive type）"></a>基本类型（primitive type）</h4><p>基本类型暴多数值型和非数值型，数值型中有证书和浮点数，非数值型中则有字符型和布尔型。由于一个字节占8位（bit），所以它的取值范围在2^8附近，同时由于0，所以需要在正数-1。在IEEE标准中，整数用补码标识，小数则用浮点数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八大基本数据类型</span></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30L</span>; <span class="comment">//long类型要在数字后面加个L</span></span><br><span class="line"><span class="type">short</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="comment">//需要加个F来表示踏实浮点型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">50.1F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">3.141592642425152356</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">letter</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">//字符串String 不是关键字，而是一个类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;JudeJojoker&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔值</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="引用类型（reference-type）"><a href="#引用类型（reference-type）" class="headerlink" title="引用类型（reference type）"></a>引用类型（reference type）</h4><p><img src="https://static.zhizuobiao.com/upload/20180404/1522811833475023263.png" alt="JAVA从入门到精通-Java中的数据类型"></p><p><img src="https://s2.51cto.com/images/blog/202301/31151856_63d8c0e01b63969038.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/resize,m_fixed,w_1184" alt="面试五：java数据类型及其转换_字符串"></p><h3 id="数据类型拓展以及面试题讲解"><a href="#数据类型拓展以及面试题讲解" class="headerlink" title="数据类型拓展以及面试题讲解"></a>数据类型拓展以及面试题讲解</h3><p>整数拓展： 二进制一般表示用0b开头，八进制以0开头，十六进制则用0X表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//整数拓展，进制表示，二进制0b，八进制0，十六进制0X</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0b10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0X10</span>;  <span class="comment">//十六进制0x 0-9 A-F，F相当于十进制的15</span></span><br><span class="line">    System.out.println(<span class="string">&quot;十进制：&quot;</span>+i);</span><br><span class="line">    System.out.println(<span class="string">&quot;二进制：&quot;</span>+i1);</span><br><span class="line">    System.out.println(<span class="string">&quot;八进制：&quot;</span>+i2);</span><br><span class="line">    System.out.println(<span class="string">&quot;十六进制：&quot;</span>+i3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果如下：</p><p><img src="http://cdn.sunrui.life/image-20230302164940640.png" alt="image-20230302164940640"></p><p>浮点数拓展：注意精度损失</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h2 id="变量、常量"><a href="#变量、常量" class="headerlink" title="变量、常量"></a>变量、常量</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="包机制、JavaDoc"><a href="#包机制、JavaDoc" class="headerlink" title="包机制、JavaDoc"></a>包机制、JavaDoc</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础语法&quot;&gt;&lt;a href=&quot;#Java基础语法&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法&quot;&gt;&lt;/a&gt;Java基础语法&lt;/h1&gt;&lt;h2 id=&quot;注释、标识符、关键字&quot;&gt;&lt;a href=&quot;#注释、标识符、关键字&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://sunrui.life/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记（1）</title>
    <link href="http://sunrui.life/posts/32ee5bcf.html"/>
    <id>http://sunrui.life/posts/32ee5bcf.html</id>
    <published>2023-03-02T06:10:27.000Z</published>
    <updated>2023-03-15T14:43:56.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h1><ul><li>语法与C相似</li><li>没有指针，内存管理</li><li>可移植性，一次编写，到处运行</li><li>面向对象</li></ul><h2 id="Java初生"><a href="#Java初生" class="headerlink" title="Java初生"></a>Java初生</h2><p>图形界面程序Applet</p><p>Java 2 标准版（J2SE）：桌面端</p><p>Java 2 移动版（J2ME）：移动端</p><p>Java 2 企业版（J2EE）：服务器端</p><h2 id="Java发展"><a href="#Java发展" class="headerlink" title="Java发展"></a>Java发展</h2><p>例如构建工具：Maven，Jekins</p><p>应用服务器：Tomcat，Jetty等</p><p>Web开发：Struts，Spring，Hibernate，MyBatis</p><p>开发工具：Eclipse，Idea等</p><p>Hadoop（大数据领域）</p><p>Android（手机端）</p><h2 id="Java的特性和优势"><a href="#Java的特性和优势" class="headerlink" title="Java的特性和优势"></a>Java的特性和优势</h2><ul><li>简单性（没有头文件，指针这些，语法类似于C）</li><li>面向对象</li><li>可移植性（跨平台）</li><li>高性能（即时编译）</li><li>分布式（通过URL可以访问网络上的资源，可以通过网络调用方法）</li><li>动态性（有反射机制）</li><li>多线程（交互更好，比如同时上QQ和打游戏）</li><li>安全性（为了满足分布式，需要更大的安全性；会进行内存检查，防止崩溃，还有异常机制）</li><li>健壮性</li></ul><h2 id="Java三大版本"><a href="#Java三大版本" class="headerlink" title="Java三大版本"></a>Java三大版本</h2><p>Write Once，Run Anywhere（JVM跨平台）</p><p>JavaSE：标准版（桌面程序，控制台开发…）</p><p>JavaME：嵌入式开发（手机，小家电…）</p><p>JavaEE：E企业级开发（web端，服务器开发）</p><h2 id="JDK，JRE，JVM"><a href="#JDK，JRE，JVM" class="headerlink" title="JDK，JRE，JVM"></a>JDK，JRE，JVM</h2><p>JDK：Java Development Kit（Java开发者工具）</p><p>JRE：Java Runtime Environment（Java运行环境）</p><p>JVM：Java Virtual Machine（Java虚拟机）</p><p><img src="https://javabeginnerstutorial.com/wp-content/uploads/2015/07/JDK_JRE_JVM-1.jpg" alt="JDK vs JRE vs JVM"></p><h2 id="Java环境搭载"><a href="#Java环境搭载" class="headerlink" title="Java环境搭载"></a>Java环境搭载</h2><h3 id="JDK安装目录说明"><a href="#JDK安装目录说明" class="headerlink" title="JDK安装目录说明"></a>JDK安装目录说明</h3><p><img src="http://cdn.sunrui.life/%E6%88%AA%E5%B1%8F2023-03-02%2014.43.10.png" alt="mac环境下zulu jdk目录"></p><p>bin目录下有很多可执行文件/应用程序，例如java，javac</p><p>include存放了很多头文件</p><p>lib里存放了库文件</p><h2 id="HelloWorld及简单的语法规则"><a href="#HelloWorld及简单的语法规则" class="headerlink" title="HelloWorld及简单的语法规则"></a>HelloWorld及简单的语法规则</h2><ol><li>新建一个文件夹存放代码</li><li>新建一个java文件<ul><li>后缀名为.java，<strong>命名为Hello.java</strong>（与Java的类名相同）</li><li>windows系统可能不显示后缀，可以显示打开</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>执行javac Hello.java编译成成.class文件</p><p><img src="http://cdn.sunrui.life/%E6%88%AA%E5%B1%8F2023-03-02%2015.10.34.png" alt="编译"></p></li></ol><p><img src="http://cdn.sunrui.life/%E6%88%AA%E5%B1%8F2023-03-02%2015.08.41.png" alt="生成了.class文件"></p><ol><li>执行java Hello命令成功在控制台输出</li></ol><p><img src="http://cdn.sunrui.life/%E6%88%AA%E5%B1%8F2023-03-02%2015.12.36.png" alt="成功在控制台输出"></p><h3 id="可能遇到的情况"><a href="#可能遇到的情况" class="headerlink" title="可能遇到的情况"></a>可能遇到的情况</h3><ul><li>每个单词的大小写不能出错，Java对大小写很敏感</li><li>尽量使用英文</li><li>类名和文件名必须保证一致</li></ul><h2 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h2><ul><li>编译型（compile，用编译器“直接全文翻译“）</li><li>解释型（用一下翻译一下）</li></ul><p>而Java具有二者的特点。二者一个即时翻译一个需要时间，前者执行速度更快，对操作系统要求较低（如C、C++），后者例如一些网页和服务型脚本可以用，其对速度要求不高。</p><p>Java先对源文件进行预编译形成字节码文件，字节码文件放进虚拟类装载器即加载到JVM里，然后校验通过后用解释器提交给操作系统。由于硬件的提升，现在二者速度差距不大。</p><p><img src="https://img-blog.csdnimg.cn/fc53b4ae12f54365b3e34913872532b2.png" alt=""></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java入门&quot;&gt;&lt;a href=&quot;#Java入门&quot; class=&quot;headerlink&quot; title=&quot;Java入门&quot;&gt;&lt;/a&gt;Java入门&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;语法与C相似&lt;/li&gt;
&lt;li&gt;没有指针，内存管理&lt;/li&gt;
&lt;li&gt;可移植性，一次编写，到处运</summary>
      
    
    
    
    
    <category term="Java" scheme="http://sunrui.life/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hexo d出现‘can not read a block mapping entry...’问题</title>
    <link href="http://sunrui.life/posts/d69ac772.html"/>
    <id>http://sunrui.life/posts/d69ac772.html</id>
    <published>2023-03-01T08:32:28.000Z</published>
    <updated>2023-03-15T14:43:56.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo部署问题：can-not-read-a-block-mapping-entry"><a href="#hexo部署问题：can-not-read-a-block-mapping-entry" class="headerlink" title="hexo部署问题：can not read a block mapping entry."></a>hexo部署问题：can not read a block mapping entry.</h3><p>在第一次通过hexo d命令部署时出现了低级问题：</p><p>报错说明中应该是说说出在tags处有语法问题，应该用换行加上“-”，同时要注意在每个“：”后面都应该有空格。</p><p><img src="http://cdn.sunrui.life/%E6%88%AA%E5%B1%8F2023-03-01%2016.28.09.png" alt="报错图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;hexo部署问题：can-not-read-a-block-mapping-entry&quot;&gt;&lt;a href=&quot;#hexo部署问题：can-not-read-a-block-mapping-entry&quot; class=&quot;headerlink&quot; title=&quot;hexo部署</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://sunrui.life/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>集合、数组、列表</title>
    <link href="http://sunrui.life/posts/1d0f5724.html"/>
    <id>http://sunrui.life/posts/1d0f5724.html</id>
    <published>2023-03-01T07:53:27.000Z</published>
    <updated>2023-03-15T14:43:56.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挑战五天提升Java水平（1-5）"><a href="#挑战五天提升Java水平（1-5）" class="headerlink" title="挑战五天提升Java水平（1/5）"></a>挑战五天提升Java水平（1/5）</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>定义：一般来说是由一个或多个元素所构成的整体.</p><p>通俗来说集合就是将一组事务组合在一起。</p></blockquote><p>其特点如下：</p><ul><li>集合里的元素不一定类型相同</li><li>集合里的元素没有顺序这一说法<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2></li></ul><blockquote><p>是一种数据项构成的<strong>有序</strong>序列，按照一定的线性顺序排列而成的数据项的集合</p><p>通常我们有数组和链表作为其常见的表现形式，特殊一点的有栈和队列，这些都是数据结构中常见的。</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组是常见的列表的实现方式，他的<strong>存储方式是连续</strong>的，且具有<strong>索引</strong>，在编程语言中一般从0开始进行索引。</p><p> 数组虽然是列表的实现方式但与列表仍然有一定的差别。在Java和C++语言中，数组存储的是具有相同数据类型的元素，而在Python中则不同，其可以存储更多类型，在Python中，数组叫做List。</p></blockquote><h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><p>由于数组的存储方式是连续的，可以将其想象成在一大片方格中进行存储。首先计算机会为了数组申请一片内存，可以用一块方格进行表示，同时计算机会记下索引为0时的地址，这样在通过索引读取的时候就可以计算来判断该位置存储的元素。其时间复杂度为O（1）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;挑战五天提升Java水平（1-5）&quot;&gt;&lt;a href=&quot;#挑战五天提升Java水平（1-5）&quot; class=&quot;headerlink&quot; title=&quot;挑战五天提升Java水平（1/5）&quot;&gt;&lt;/a&gt;挑战五天提升Java水平（1/5）&lt;/h1&gt;&lt;h2 id=&quot;集合&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://sunrui.life/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://sunrui.life/posts/4a17b156.html"/>
    <id>http://sunrui.life/posts/4a17b156.html</id>
    <published>2023-02-28T07:17:19.323Z</published>
    <updated>2023-03-15T14:43:56.358Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
